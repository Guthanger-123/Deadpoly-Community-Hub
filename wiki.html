<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Wiki - 3D Viewer</title>

  <style>
    :root{
      --bg:#0b0d12;
      --panel:#111522;
      --panel2:#0f1220;
      --text:#e8ecff;
      --muted:#aeb7d9;
      --line:rgba(255,255,255,.10);
      --btn:#1b2336;
      --btn2:#23304a;
      --accent:#4aa3ff;
      --top:56px;
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; background:var(--bg); color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }

    /* Top bar */
    .topbar{
      position:sticky; top:0; z-index:50;
      height:var(--top);
      display:flex; align-items:center; justify-content:space-between;
      padding:0 12px;
      background:linear-gradient(to bottom, rgba(10,12,18,.98), rgba(10,12,18,.92));
      border-bottom:1px solid var(--line);
      backdrop-filter: blur(10px);
    }
    .topbar .left, .topbar .right{ display:flex; gap:10px; align-items:center; }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px; border-radius:10px;
      background:rgba(255,255,255,.06);
      border:1px solid var(--line);
      color:var(--text); text-decoration:none;
      font-size:13px;
    }
    .pill:hover{ border-color:rgba(255,255,255,.22); }
    .title{
      font-weight:800; letter-spacing:.3px;
      font-size:14px; opacity:.95;
    }
    .hint{ font-size:12px; color:var(--muted); margin-left:10px; }

    /* Layout */
    .wrap{
      height: calc(100vh - var(--top)); /* CRITICAL: gives #stage real height via children */
      display:grid;
      grid-template-columns: 1fr 330px;
      gap:12px;
      padding:12px;
    }
    @media (max-width: 980px){
      .wrap{ grid-template-columns: 1fr; height:auto; min-height: calc(100vh - var(--top)); }
    }

    /* Viewer */
    .viewerCard{
      position:relative;
      background:radial-gradient(1200px 700px at 50% 15%, rgba(90,120,255,.15), rgba(0,0,0,0) 55%),
                 linear-gradient(to bottom, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius:14px;
      overflow:hidden;
      min-height: 520px;
    }
    /* CRITICAL: stage must fill card */
    #stage{
      position:absolute; inset:0;
      width:100%;
      height:100%;
    }

    .hud{
      position:absolute; left:12px; bottom:12px; z-index:5;
      display:flex; gap:8px; flex-wrap:wrap;
      pointer-events:none;
    }
    .hud .chip{
      pointer-events:none;
      padding:6px 9px; border-radius:999px;
      background:rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.12);
      color:var(--text);
      font-size:12px;
    }

    /* Side panel */
    .side{
      background:linear-gradient(to bottom, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px;
      overflow:auto;
      min-height: 520px;
    }
    .side h3{ margin:0 0 6px; font-size:14px; }
    .side p{ margin:6px 0; color:var(--muted); font-size:12.5px; line-height:1.4; }

    .btn{
      width:100%;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--line);
      background:linear-gradient(to bottom, var(--btn2), var(--btn));
      color:var(--text);
      font-weight:700;
      cursor:pointer;
      margin-top:10px;
    }
    .btn:hover{ border-color:rgba(255,255,255,.22); }
    .btn.secondary{ font-weight:700; background:rgba(255,255,255,.05); }

    .box{
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.25);
      font-size:12px;
      color:var(--muted);
      overflow:auto;
    }
    code{ color:#d7e6ff; }
    .status{
      margin-top:10px;
      font-size:12px;
      color:var(--muted);
    }
    .status b{ color:var(--text); }
  </style>

  <!-- Import map: no downloads needed. Works on GitHub Pages. -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>

<body>
  <div class="topbar">
    <div class="left">
      <a class="pill" href="index.html">← Menu</a>
      <div class="title">Wiki - 3D Viewer</div>
      <div class="hint">Drag rotate • Scroll zoom • Right-drag pan</div>
    </div>
    <div class="right">
      <a class="pill" href="tips.html">Tips</a>
      <a class="pill" href="maps.html">Maps</a>
    </div>
  </div>

  <div class="wrap">
    <div class="viewerCard">
      <div id="stage" aria-label="3D viewer stage"></div>

      <div class="hud">
        <div class="chip" id="hudStatus">Status: Ready</div>
        <div class="chip" id="hudLoaded">Loaded: none</div>
      </div>
    </div>

    <aside class="side">
      <h3>Controls</h3>
      <p>Loads FBX from <code>/assets/models/</code></p>

      <button class="btn" id="btnLoadBase">Load Base Model</button>
      <button class="btn secondary" id="btnReset">Reset View</button>
      <button class="btn secondary" id="btnClear">Clear Scene</button>

      <div class="box">
        Base FBX path used:<br>
        <code>assets/models/SK_BaseModel.fbx</code><br><br>
        If you see a grid + axes, Three.js is working.
        If FBX loads but looks blank, it’s usually camera framing or scale — this page auto-frames after load.
      </div>

      <div class="status" id="statusText"><b>Debug:</b> waiting…</div>
    </aside>
  </div>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { FBXLoader } from "three/addons/loaders/FBXLoader.js";

    const stage = document.getElementById("stage");
    const hudStatus = document.getElementById("hudStatus");
    const hudLoaded = document.getElementById("hudLoaded");
    const statusText = document.getElementById("statusText");

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0d12);

    const camera = new THREE.PerspectiveCamera(45, 1, 0.01, 2000);
    camera.position.set(0, 1.4, 3.2);

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    stage.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.target.set(0, 1.0, 0);

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.85));
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(3, 6, 4);
    scene.add(dir);

    // Grid + axes (so you always see something)
    const grid = new THREE.GridHelper(20, 20, 0x335577, 0x223344);
    grid.position.y = 0;
    scene.add(grid);
    const axes = new THREE.AxesHelper(1.2);
    scene.add(axes);

    // Keep loaded models in a group so we can clear easily
    const modelRoot = new THREE.Group();
    scene.add(modelRoot);

    function setHud(msg, loaded) {
      hudStatus.textContent = "Status: " + msg;
      statusText.innerHTML = "<b>Debug:</b> " + msg;
      if (loaded !== undefined) hudLoaded.textContent = "Loaded: " + loaded;
    }

    // CRITICAL: size renderer from the real element size
    function resize() {
      const w = stage.clientWidth;
      const h = stage.clientHeight;
      if (!w || !h) return; // if hidden/collapsed momentarily
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }

    // Use ResizeObserver so it works on mobile/desktop and when panels resize
    const ro = new ResizeObserver(() => resize());
    ro.observe(stage);
    window.addEventListener("orientationchange", () => setTimeout(resize, 50));
    window.addEventListener("resize", () => setTimeout(resize, 50));
    resize();

    function clearModel() {
      while (modelRoot.children.length) {
        const obj = modelRoot.children.pop();
        obj.traverse?.(n => {
          if (n.geometry) n.geometry.dispose?.();
          if (n.material) {
            const mats = Array.isArray(n.material) ? n.material : [n.material];
            mats.forEach(m => {
              for (const k in m) {
                if (m[k] && m[k].isTexture) m[k].dispose?.();
              }
              m.dispose?.();
            });
          }
        });
      }
      setHud("Cleared scene", "none");
    }

    function frameObject(object3D) {
      // Compute bounding box
      const box = new THREE.Box3().setFromObject(object3D);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());

      // Recenter the model around origin-ish
      object3D.position.sub(center);

      // Fit camera to model
      const maxDim = Math.max(size.x, size.y, size.z) || 1;
      const fitDist = maxDim / (2 * Math.tan(THREE.MathUtils.degToRad(camera.fov * 0.5)));
      const dist = fitDist * 1.35;

      camera.position.set(0, maxDim * 0.35 + 1.0, dist);
      controls.target.set(0, maxDim * 0.35, 0);
      controls.update();
    }

    async function loadFBX(path, label) {
      setHud("Loading…", label);
      const loader = new FBXLoader();

      return new Promise((resolve, reject) => {
        loader.load(
          path,
          (obj) => {
            // Make sure it renders even if materials are weird
            obj.traverse((n) => {
              if (n.isMesh) {
                n.castShadow = false;
                n.receiveShadow = false;

                // If FBX has no material, give it one
                if (!n.material) {
                  n.material = new THREE.MeshStandardMaterial({ color: 0xbfc7ff, roughness: 0.85, metalness: 0.0 });
                } else {
                  // If material exists but is too dark, bump emissive slightly
                  const mats = Array.isArray(n.material) ? n.material : [n.material];
                  mats.forEach(m => {
                    if (m.color) m.color.convertSRGBToLinear?.();
                    if ("emissive" in m) m.emissiveIntensity = Math.max(m.emissiveIntensity || 0, 0.15);
                  });
                }
              }
            });

            modelRoot.add(obj);
            frameObject(obj);
            setHud("Loaded", label);
            resolve(obj);
          },
          (evt) => {
            if (evt.total) {
              const pct = Math.round((evt.loaded / evt.total) * 100);
              setHud(`Loading… ${pct}%`, label);
            }
          },
          (err) => {
            console.error(err);
            setHud("Failed to load (check path / case / 404)", label);
            reject(err);
          }
        );
      });
    }

    // Buttons
    document.getElementById("btnLoadBase").addEventListener("click", async () => {
      clearModel();
      try {
        await loadFBX("assets/models/SK_BaseModel.fbx", "SK_BaseModel.fbx");
      } catch {}
    });

    document.getElementById("btnClear").addEventListener("click", () => clearModel());

    document.getElementById("btnReset").addEventListener("click", () => {
      camera.position.set(0, 1.4, 3.2);
      controls.target.set(0, 1.0, 0);
      controls.update();
      setHud("Reset view", hudLoaded.textContent.replace("Loaded: ",""));
    });

    // Render loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    setHud("Ready (grid + axes should be visible)", "none");
  </script>
</body>
</html>
